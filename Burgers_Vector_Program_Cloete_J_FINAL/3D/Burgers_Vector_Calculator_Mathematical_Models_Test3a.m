% Burger_Vector_Calculator_Mathematical_Models

% This script was made to make a plot of the performance of the program
% with the 3D data set to be used for analysis in the program's associated 
% paper

%% Introduction
% Computes the Burgers vector for a specified Burgers circuit from elastic
% strain and lattice rotation data generated by the mathematical model for 
% a mixed dislocation and outputs its direction and magnitude.
% Optionally, there is implementation for drawing several similar Burgers
% circuits and finding the mean-average Burgers vector (this would be
% useful if the data is too noisy to provide accurate results from a single
% Burgers circuit).


%% Defining the Parameters for the Mathematical Model
% Note that the data for the elastic strains and lattice rotations must be
% input into a 5D strains array.

% The strains tensor should be assembled as a
% (y_length) x ((x_length) x (z_length) x 3 x 3 array:

%                                    [ e11 e12 e13 ]
%  strains(y_pos,x_pos,z_pos,:,:) =  [ wz  e22 e23 ]
%                                    [ wy  wx  e33 ]

% Where each of the above elements have the definitions found in HLT.

% In addition, when constructing the strains array, the first elements in
% the x- and z-directions must correspond to the most negative x- and
% z-coordinates, but the first element in the y-direction must correspond
% to the most positive y-coordinate. This is so that the strains array
% is arranged to imitate a traditional 3D Cartesian coordinate system for
% the purposes of defining the Burgers circuit for numerical integration.

% Note that the most negative x- and z-coordinates and the most positive
% y-coordinate for the sample data are also required for the snippet
% function.


% Define the interval between adjacent voxels of input data in metres:
% The program assumes that the voxels are equally spaced in each direction.
interval = 5e-9;    % (m)


% Ideal model of a mixed dislocation:

% Define the desired magnitude of the Burgers vector (The program will 
% effectively verify that this is the case):
b = 1e-10;  % (m)

% Define the Poisson's ratio of the hypothetical material:
v = 0.3;

% The translate parameters define the translation of the dislocation line
% from the origin in the directions of each of the positive coordinate
% axes.
x_translate = 0;  % (m)
y_translate = 0;  % (m)
z_translate = 0;  % (m)

% The angles alpha through phi are as defined in the program's associated 
% paper.
alpha = 0;        % (degrees)
psi = 0;          % (degrees)
theta = 0;        % (degrees)
phi = 0;          % (degrees)


%% Defining the Burgers Circuit
% Here we define the values of x, y and z that determine the cuboid around
% which the Burgers circuit is defined. The larger the ranges, and the
% further the dislocation centre from one of the limits, the more accurate
% the resulting Burgers vector. However it should be noted that fluctuation
% in the elements of the computed Burgers vector is small until the
% lengths of the Burgers circuit are less than 9 voxels and/or the
% dislocation centre is within a few voxels of the Burgers circuit.

% If you want to calculate a set of Burgers vectors to find a mean-average,
% note that the additional Burgers circuits will all be smaller than the
% first, 'outermost' one, so make sure that the limits defined below are
% large and/or the values of i and j are low. Improved results over a
% single loop is only expected if the data is very noisy.

concentric_tot = 1;
it_tot = 100;
magnitude_percentage_error = zeros(it_tot,concentric_tot);
angular_separation = zeros(it_tot,concentric_tot);
noise_vals = zeros(it_tot,1);
b_true = [1;1;1]*1e-10;

    
    % Define the x-limits of the input data in lab coordinates (in m)
    xlims = [-102.5e-9 102.5e-9];    % x-limits (m)
    
    % Define the y-limits of the input data in lab coordinates (in m)
    % (Note the upper limit is the first entry for the y-direction)
    ylims = [102.5e-9 -102.5e-9];    % y-limits (m)
    
    % Define the z-limits of the input data in lab coordinates (in m)
    zlims = [-102.5e-9 102.5e-9];    % z-limits (m)
    
    
    %% Generating the Data and Computing the Burgers Vector
    % We shall generate the strain data for the chosen Burgers circuit, and
    % then integrate numerically to compute the Burgers vector.
    
    % Generate the strains array for the given inputs:
    %strains = mixed(xlims,ylims,zlims,interval,b,v,x_translate,y_translate,z_translate,alpha,psi,theta,phi);
    strains = mixed(xlims,ylims,zlims,interval,b,v,x_translate,y_translate,z_translate,0,0,0,0) + mixed(xlims,ylims,zlims,interval,b,v,x_translate,y_translate,z_translate,0,0,90,0) + mixed(xlims,ylims,zlims,interval,b,v,x_translate,y_translate,z_translate,0,0,90,90);

    pd = makedist('Normal');
    truncated = truncate(pd,-1,1);

    for it = 1:it_tot
            % Generate noise to superpose onto the strains array:
            generate_noise = 'Y';
            
            if generate_noise == 'Y'
                % Define the noise itself. Here it as been implemented as the standard
                % Gaussian distribution multiplied by a chosen coefficient.
                nc = 1e-6*exp(it/15);  % Noise Coefficient
                noise = random(truncated,size(strains))*nc;
                strains = strains + noise;
                
%                 for p = 1:3
%                     for q = 1:3
%                         strains(:,:,:,p,q) = imgaussfilt3(strains(:,:,:,p,q));
%                     end
%                 end
                
            end


        for concentric = 1:concentric_tot
            % Convert the strains array into the displacement gradient field, which we
            % shall use to perform the numerical integration:
            beta = strains2beta(strains);
            
            % Determine whether a single Burgers circuit or many similar ones is to be
            % used:
            average = 'Y';
            
            if average == 'N'
                % Compute the Burgers vector from this snippet:
                b_computed = find_burgers_vector_accurate(interval,xlims,ylims,zlims,beta);
                
            elseif average == 'Y'
                % Alternatively, compute a set of Burgers vectors for many similar Burgers
                % circuits from this snippet:
                
                % Number of concentric Burgers circuits per 'layer':
                i = (concentric-1);
                
                % Number of 'layers' of Burgers circuits:
                j = 0;
                
                % Compute the set of Burgers vectors from this snippet:
                b_computed_set = find_burgers_vector_repeated(interval,xlims,ylims,zlims,beta,i,j);
                
                for row = 1:3
                    [B,TF] = rmoutliers(b_computed_set(row,:),'mean','ThresholdFactor',1.5);
                    b_computed_set = b_computed_set(:,not(TF));
                end
                
                % Compute the mean-average Burgers vector:
                b_computed_set_size = size(b_computed_set);
                b_computed = sum(b_computed_set,2)/b_computed_set_size(2);
                
            end
            
            
            % For better insight, we can describe the computed Burgers vector in terms
            % of its direction and magnitude:
            
            % Find the unit vector in the direction of the Burgers vector:
            b_direction = b_computed/norm(b_computed);
            angular_separation(it,concentric) = real(acosd(dot(b_true/norm(b_true),b_computed/norm(b_computed))));
            % Find the magnitude of the Burgers vector:
            b_magnitude = norm(b_computed);
            magnitude_percentage_error(it,concentric) = abs((norm(b_true)-b_magnitude)/norm(b_true)*100);
            
        end
        noise_vals(it) = nc;
    end

concentric_vector = 1:concentric_tot;
for concentric = 1:concentric_tot
    h1 = subplot(1,2,1);
    hold on
    loglog(noise_vals,magnitude_percentage_error(:,concentric),'b')
    ylabel('Error in Magnitude (%)')
    logx1 = log(noise_vals);
    logy1 = log(magnitude_percentage_error(:,concentric));
    Const1 = polyfit(logx1, logy1, 1);
    z1 = polyval(Const1,logx1);
    loglog(noise_vals,exp(z1),'--k')
    set(gca, 'XScale', 'log', 'YScale', 'log');
    %set(gca, 'YScale', 'log');
    grid on
    
    h2 = subplot(1,2,2);
    hold on
    loglog(noise_vals,angular_separation(:,concentric),'r')
    ylabel(['Angular Separation (' char(176) ')'])
    logx2 = log(noise_vals);
    logy2 = log(angular_separation(:,concentric));
    Const2 = polyfit(logx2, logy2, 1);
    z2 = polyval(Const2,logx2);
    loglog(noise_vals,exp(z2),'--k')
    set(gca,'XScale', 'log','YScale','log');
    %set(gca, 'YScale', 'log');
    grid on
end

[ax,h2]=suplabel('Noise Coefficient (strain)','x');

sgtitle('Test 3A - Variation of Computed Burgers Vector with Noise')