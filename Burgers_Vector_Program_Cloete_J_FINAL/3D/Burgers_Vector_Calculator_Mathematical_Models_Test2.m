% Burger_Vector_Calculator_Mathematical_Models

% This script was made to make a plot of the performance of the program
% with the 3D data set to be used for analysis in the program's associated 
% paper

%% Introduction
% Computes the Burgers vector for a specified Burgers circuit from elastic
% strain and lattice rotation data generated by the mathematical model for 
% a mixed dislocation and outputs its direction and magnitude.
% Optionally, there is implementation for drawing several similar Burgers
% circuits and finding the mean-average Burgers vector (this would be
% useful if the data is too noisy to provide accurate results from a single
% Burgers circuit).


%% Defining the Parameters for the Mathematical Model
% Note that the data for the elastic strains and lattice rotations must be
% input into a 5D strains array.

% The strains tensor should be assembled as a
% (y_length) x ((x_length) x (z_length) x 3 x 3 array:

%                                    [ e11 e12 e13 ]
%  strains(y_pos,x_pos,z_pos,:,:) =  [ wz  e22 e23 ]
%                                    [ wy  wx  e33 ]

% Where each of the above elements have the definitions found in HLT.

% In addition, when constructing the strains array, the first elements in
% the x- and z-directions must correspond to the most negative x- and
% z-coordinates, but the first element in the y-direction must correspond
% to the most positive y-coordinate. This is so that the strains array
% is arranged to imitate a traditional 3D Cartesian coordinate system for
% the purposes of defining the Burgers circuit for numerical integration.

% Note that the most negative x- and z-coordinates and the most positive
% y-coordinate for the sample data are also required for the snippet
% function.


% Define the interval between adjacent voxels of input data in metres:
% The program assumes that the voxels are equally spaced in each direction.
interval = 5e-9;    % (m)


% Ideal model of a mixed dislocation:

% Define the desired magnitude of the Burgers vector (The program will 
% effectively verify that this is the case):
b = 1e-10;  % (m)

% Define the Poisson's ratio of the hypothetical material:
v = 0.3;

% The translate parameters define the translation of the dislocation line
% from the origin in the directions of each of the positive coordinate
% axes.
x_translate = 0;  % (m)
y_translate = 0;  % (m)
z_translate = 0;  % (m)

% The angles alpha through phi are as defined in the program's associated 
% paper.
alpha = 0;        % (degrees)
psi = 0;          % (degrees)
theta = 0;        % (degrees)
phi = 0;          % (degrees)


%% Defining the Burgers Circuit
% Here we define the values of x, y and z that determine the cuboid around
% which the Burgers circuit is defined. The larger the ranges, and the
% further the dislocation centre from one of the limits, the more accurate
% the resulting Burgers vector. However it should be noted that fluctuation
% in the elements of the computed Burgers vector is small until the
% lengths of the Burgers circuit are less than 9 voxels and/or the
% dislocation centre is within a few voxels of the Burgers circuit.

% If you want to calculate a set of Burgers vectors to find a mean-average,
% note that the additional Burgers circuits will all be smaller than the
% first, 'outermost' one, so make sure that the limits defined below are
% large and/or the values of i and j are low. Improved results over a
% single loop is only expected if the data is very noisy.

magnitude_percentage_error = zeros(21,1);
angular_separation = zeros(21,1);
distance_from_edge = zeros(21,1);
b_true = [1;1;1]*1e-10;

for it = 1:21
    
    % Define the x-limits of the input data in lab coordinates (in m)
    xlims = [(-102.5+(it-1)*5)*1e-9 (102.5+(it-1)*5)*1e-9];    % x-limits (m)
    
    % Define the y-limits of the input data in lab coordinates (in m)
    % (Note the upper limit is the first entry for the y-direction)
    ylims = [(102.5+(it-1)*5)*1e-9 (-102.5+(it-1)*5)*1e-9];    % y-limits (m)
    
    % Define the z-limits of the input data in lab coordinates (in m)
    zlims = [(-102.5+(it-1)*5)*1e-9 (102.5+(it-1)*5)*1e-9];    % z-limits (m)
    
    
    %% Generating the Data and Computing the Burgers Vector
    % We shall generate the strain data for the chosen Burgers circuit, and
    % then integrate numerically to compute the Burgers vector.
    
    % Generate the strains array for the given inputs:
    %strains = mixed(xlims,ylims,zlims,interval,b,v,x_translate,y_translate,z_translate,alpha,psi,theta,phi);
    strains = mixed(xlims,ylims,zlims,interval,b,v,x_translate,y_translate,z_translate,0,0,0,0) + mixed(xlims,ylims,zlims,interval,b,v,x_translate,y_translate,z_translate,0,0,90,0) + mixed(xlims,ylims,zlims,interval,b,v,x_translate,y_translate,z_translate,0,0,90,90);
    
    % Generate noise to superpose onto the strains array:
    generate_noise = 'N';
    
    if generate_noise == 'Y'
        % Define the noise itself. Here it as been implemented as the standard
        % Gaussian distribution multiplied by a chosen coefficient.
        nc = 1e-6;  % Noise Coefficient
        noise = randn(size(strains))*nc;
        strains = strains + noise;
    end
    
    % Convert the strains array into the displacement gradient field, which we
    % shall use to perform the numerical integration:
    beta = strains2beta(strains);
    
    % Determine whether a single Burgers circuit or many similar ones is to be
    % used:
    average = 'N';
    
    if average == 'N'
        % Compute the Burgers vector from this snippet:
        b_computed = find_burgers_vector_accurate(interval,xlims,ylims,zlims,beta);
        
    elseif average == 'Y'
        % Alternatively, compute a set of Burgers vectors for many similar Burgers
        % circuits from this snippet:
        
        % Number of concentric Burgers circuits per 'layer':
        i = 1;
        
        % Number of 'layers' of Burgers circuits:
        j = 1;
        
        % Compute the set of Burgers vectors from this snippet:
        b_computed_set = find_burgers_vector_repeated(interval,xlims,ylims,zlims,beta,i,j);
        
        % Compute the mean-average Burgers vector:
        b_computed = sum(b_computed_set,2)/((i+1)*(j+1));
        
    end
    
    
    % For better insight, we can describe the computed Burgers vector in terms
    % of its direction and magnitude:
    
    % Find the unit vector in the direction of the Burgers vector:
    b_direction = b_computed/norm(b_computed);
    angular_separation(it) = real(acosd(dot(b_true/norm(b_true),b_computed/norm(b_computed))));
    % Find the magnitude of the Burgers vector:
    b_magnitude = norm(b_computed);
    magnitude_percentage_error(it) = abs((norm(b_true)-b_magnitude)/norm(b_true)*100);
    
    distance_from_edge(it) = (it-1)/21;
end

h1 = subplot(1,2,1);
semilogy(distance_from_edge,magnitude_percentage_error,'b')
ylabel('Error in Magnitude (%)')
grid on


h2 = subplot(1,2,2);
semilogy(distance_from_edge,angular_separation,'r')
ylabel(['Angular Separation (' char(176) ')'])
grid on

[ax,h2]=suplabel('Ratio of [Distance of Dislocation from Burgers Circuit Centre]/[Distance between Burgers Circuit Edge and Centre]','x');

sgtitle('Test 2 - Variation of Computed Burgers Vector with Fractional Distance of Dislocation from Burgers Circuit Centre')