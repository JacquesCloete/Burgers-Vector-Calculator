% Burger_Vector_Calculator_Mathematical_Models

%% Introduction
% Computes the Burgers vector for a specified Burgers circuit from elastic
% strain and lattice rotation data generated by the mathematical model for 
% a mixed dislocation and outputs its direction and magnitude.
% Optionally, there is implementation for drawing several similar Burgers
% circuits and finding the mean-average Burgers vector (this would be
% useful if the data is too noisy to provide accurate results from a single
% Burgers circuit).


%% Defining the Parameters for the Mathematical Model
% Note that the data for the elastic strains and lattice rotations must be
% input into a 5D strains array.

% The strains tensor should be assembled as a
% (y_length) x ((x_length) x (z_length) x 3 x 3 array:

%                                    [ e11 e12 e13 ]
%  strains(y_pos,x_pos,z_pos,:,:) =  [ wz  e22 e23 ]
%                                    [ wy  wx  e33 ]

% Where each of the above elements have the definitions found in HLT.

% In addition, when constructing the strains array, the first elements in
% the x- and z-directions must correspond to the most negative x- and
% z-coordinates, but the first element in the y-direction must correspond
% to the most positive y-coordinate. This is so that the strains array
% is arranged to imitate a traditional 3D Cartesian coordinate system for
% the purposes of defining the Burgers circuit for numerical integration.

% Note that the most negative x- and z-coordinates and the most positive
% y-coordinate for the sample data are also required for the snippet
% function.


% Define the interval between adjacent voxels of input data in metres:
% The program assumes that the voxels are equally spaced in each direction.
interval = 5e-9;    % (m)


% Ideal model of a mixed dislocation:

% Define the desired magnitude of the Burgers vector (The program will 
% effectively verify that this is the case):
b = 1e-10;  % (m)

% Define the Poisson's ratio of the hypothetical material:
v = 0.3;

% The translate parameters define the translation of the dislocation line
% from the origin in the directions of each of the positive coordinate
% axes.
x_translate = 0;  % (m)
y_translate = 0;  % (m)
z_translate = 0;  % (m)

% The angles alpha through phi are as defined in the program's associated 
% paper.
alpha = 0;        % (degrees)
psi = 0;          % (degrees)
theta = 0;        % (degrees)
phi = 0;          % (degrees)


%% Defining the Burgers Circuit
% Here we define the values of x, y and z that determine the cuboid around
% which the Burgers circuit is defined. The larger the ranges, and the
% further the dislocation centre from one of the limits, the more accurate
% the resulting Burgers vector. However it should be noted that fluctuation
% in the elements of the computed Burgers vector is small until the
% lengths of the Burgers circuit are less than 9 voxels and/or the
% dislocation centre is within a few voxels of the Burgers circuit.

% If you want to calculate a set of Burgers vectors to find a mean-average,
% note that the additional Burgers circuits will all be smaller than the
% first, 'outermost' one, so make sure that the limits defined below are
% large and/or the values of i and j are low. Improved results over a
% single loop is only expected if the data is very noisy.

% Define the x-limits of the input data in lab coordinates (in m)
xlims = [-102.5e-9 102.5e-9];    % x-limits (m)

% Define the y-limits of the input data in lab coordinates (in m)
% (Note the upper limit is the first entry for the y-direction)
ylims = [102.5e-9 -102.5e-9];    % y-limits (m)

% Define the z-limits of the input data in lab coordinates (in m)
zlims = [-102.5e-9 102.5e-9];    % z-limits (m)


%% Generating the Data and Computing the Burgers Vector
% We shall generate the strain data for the chosen Burgers circuit, and
% then integrate numerically to compute the Burgers vector.

% Generate the strains array for the given inputs:
strains = mixed(xlims,ylims,zlims,interval,b,v,x_translate,y_translate,z_translate,alpha,psi,theta,phi);

% Generate noise to superpose onto the strains array:
generate_noise = 'N';

if generate_noise == 'Y'
    % Define the noise itself. Here it as been implemented as the standard
    % Gaussian distribution multiplied by a chosen coefficient.
    pd = makedist('Normal');
    truncated = truncate(pd,-1,1);
    nc = 1e-4;  % Noise Coefficient
    noise = random(truncated,size(strains))*nc;
    strains = strains + noise;
end
    
% Convert the strains array into the displacement gradient field, which we
% shall use to perform the numerical integration:
beta = strains2beta(strains);

% Determine whether a single Burgers circuit or many similar ones is to be
% used:
average = 'N';

if average == 'N'
    % Compute the Burgers vector from this snippet:
    b_computed = find_burgers_vector_accurate(interval,xlims,ylims,zlims,beta);
    
elseif average == 'Y'
    % Alternatively, compute a set of Burgers vectors for many similar Burgers
    % circuits from this snippet:
    
    % Number of ADDITIONAL concentric Burgers circuits per 'layer':
    i = 1;
    
    % Number of ADDITIONAL 'layers' of Burgers circuits:
    j = 1;
    
    % Compute the set of Burgers vectors from this snippet:
    b_computed_set = find_burgers_vector_repeated(interval,xlims,ylims,zlims,beta,i,j);
    
    % Remove outliers:
    for row = 1:3
        [B,TF] = rmoutliers(b_computed_set(row,:),'mean','ThresholdFactor',1.5);    % Adjust threshold factor from 1.5 as desired
        b_computed_set = b_computed_set(:,not(TF));
    end
    
    % Compute the mean-average Burgers vector:
    b_computed = sum(b_computed_set,2)/((i+1)*(j+1));
    
end


% For better insight, we can describe the computed Burgers vector in terms
% of its direction and magnitude:

% Find the unit vector in the direction of the Burgers vector:
b_direction = b_computed/norm(b_computed);

% Find the magnitude of the Burgers vector:
b_magnitude = norm(b_computed);